/*
 * generated by Xtext 2.12.0
 */
package de.hs_coburg.mgse.platform.modulehandbook.validation

import org.eclipse.xtext.validation.Check
import de.hs_coburg.mgse.platform.modulehandbook.moduleHandbookModel.ModuleHandbookModelPackage
import de.hs_coburg.mgse.platform.modulehandbook.moduleHandbookModel.Workload
import de.hs_coburg.mgse.platform.modulehandbook.moduleHandbookModel.ModuleDescription
import de.hs_coburg.mgse.platform.ser.validation.ModuleBehavior
import de.hs_coburg.mgse.platform.modulehandbook.moduleHandbookModel.ModuleHandbook
import de.hs_coburg.mgse.platform.modulehandbook.utils.ModuleDescriptionBehavior

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ModuleHandbookModelValidator extends AbstractModuleHandbookModelValidator {
	extension ModuleBehavior = new ModuleBehavior
	extension ModuleDescriptionBehavior = new ModuleDescriptionBehavior
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					ModuleHandbookModelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	// "The version of a module handbook should be greater than 0."
	@Check
	def checkVersionOfCurriculum(ModuleHandbook mhb) {
		val version = mhb.getVersion()
		if (version <= 0)
			error('The version of a module handbook should be greater than 0', mhb, ModuleHandbookModelPackage.Literals.MODULE_HANDBOOK__VERSION)
	}

	// "The effort for a workload must be greater than 0."
	@Check
	def checkEffort(Workload workload) {
		val effort = workload.effort
		if (effort <= 0) {
			error('The effort for a workload must be greater than 0', workload, ModuleHandbookModelPackage.Literals.WORKLOAD__EFFORT)
		}
	}
	
	// "The overall effort for all workloads defined in a module description must to be equal to the semester hours specified in the module."
	@Check
	def checkOverallEffort(ModuleDescription md) {
		val workloads = md.workloads
		val moduleEffort = md.calculateMaxWorkload
		var effortSum = workloads.map[wl | wl.effort].reduce[s1, s2 | s1 + s2]
		
		if (moduleEffort != effortSum) {
			error('''The overall effort for all workloads must be equal to «moduleEffort» but actually is «effortSum»''', md, ModuleHandbookModelPackage.Literals.MODULE_DESCRIPTION__WORKLOADS)
		}
	}
	
	// "Only modules which are specified in the referenced curriculum entry can be described in the module handbook."
	@Check
	def checkSpecifiedModule(ModuleHandbook mhb) {

		val possibleEntries = mhb.curriculum.curriculumEntries
		val moduleDescriptions = mhb.moduleDescriptions
		for(moduleDescription : moduleDescriptions){
			val refEntry = moduleDescription.curriculumEntry
			if(!possibleEntries.contains(refEntry)){
				error('''The module «refEntry.name» is not part of the specified curriculum.''', moduleDescription, ModuleHandbookModelPackage.Literals.MODULE_DESCRIPTION__CURRICULUM_ENTRY)
			}
		}
	}
	
	// "All modules which are specified in the referenced curriculum entry musst be described in the module handbook."
	@Check
	def checkSpecifiedModules(ModuleHandbook mhb) {

		val curriculum_entries = mhb.curriculum.curriculumEntries
		val module_descriptions = mhb.moduleDescriptions
		
		for(curriculum_entry : curriculum_entries) {
			if(!module_descriptions.contains(curriculum_entry)) {
				error('''The module «curriculum_entry.name» needs to be defined according to specified curriculum.''', curriculum_entry, ModuleHandbookModelPackage.Literals.MODULE_DESCRIPTION__CURRICULUM_ENTRY)
			}
		}
	}
}